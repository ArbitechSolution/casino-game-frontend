{"ast":null,"code":"/*\n *                 Copyright (C) 2015 Shane Carr and others\n *                               X11 License\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Except as contained in this notice, the names of the authors or copyright\n * holders shall not be used in advertising or otherwise to promote the sale,\n * use or other dealings in this Software without prior written authorization\n * from the authors or copyright holders.\n */\n// Do not check function indentation because this is intentionally ignored in order to preserve history in git.\n\n/* eslint-disable indent */\n\n/*\n * A client-side JavaScript object to handle file uploads to a Node.JS server\n * via Socket.IO.\n * @implements EventTarget\n * @param {SocketIO} socket The current Socket.IO connection.\n */\n(function (scope, name, factory) {\n  /* eslint-disable no-undef */\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    scope[name] = factory();\n  }\n  /* eslint-enable no-undef */\n\n})(this, \"SocketIOFileUpload\", function () {\n  return function (socket, options) {\n    \"use strict\";\n\n    var self = this; // avoids context issues\n    // Check for compatibility\n\n    if (!window.File || !window.FileReader) {\n      throw new Error(\"Socket.IO File Upload: Browser Not Supported\");\n    }\n\n    if (!window.siofu_global) {\n      window.siofu_global = {\n        instances: 0,\n        downloads: 0\n      };\n    } // Private and Public Variables\n\n\n    var callbacks = {},\n        uploadedFiles = {},\n        chunkCallbacks = {},\n        readyCallbacks = {},\n        communicators = {};\n\n    var _getOption = function _getOption(key, defaultValue) {\n      if (!options) {\n        return defaultValue;\n      }\n\n      return options[key] || defaultValue;\n    };\n\n    self.fileInputElementId = \"siofu_input_\" + window.siofu_global.instances++;\n    self.resetFileInputs = true;\n    self.useText = _getOption(\"useText\", false);\n    self.serializedOctets = _getOption(\"serializedOctets\", false);\n    self.useBuffer = _getOption(\"useBuffer\", true);\n    self.chunkSize = _getOption(\"chunkSize\", 1024 * 100); // 100kb default chunk size\n\n    self.topicName = _getOption(\"topicName\", \"siofu\");\n    /**\n    * WrapData allow you to wrap the Siofu messages into a predefined format.\n    * You can then easily use Siofu packages even in strongly typed topic.\n    * wrapData can be a boolean or an object. It is false by default.\n    * If wrapData is true it will allow you to send all the messages to only one topic by wrapping the siofu actions and messages.\n    *\n    * ex:\n    {\n    \taction: 'complete',\n    \tmessage: {\n    \t id: id,\n    \t success: success,\n    \t detail: fileInfo.clientDetail\n    \t}\n    }\n    *\n    * If wrapData is an object constituted of two mandatory key and one optional:\n    * wrapKey and unwrapKey (mandatory): Corresponding to the key used to wrap the siofu data and message\n    * additionalData (optional): Corresponding to the data to send along with file data\n    *\n    * ex:\n    * if wrapData = {\n    \twrapKey: {\n    \t\taction: 'actionType',\n    \t\tmessage: 'data'\n    \t},\n    \tunwrapKey: {\n    \t\taction: 'actionType',\n    \t\tmessage: 'message'\n    \t},\n    \tadditionalData: {\n    \t\tacknowledgement: true\n    \t}\n    }\n    * When Siofu will send for example a complete message this will send:\n    *\n    {\n    \tacknowledgement: true,\n    \tactionType: 'complete',\n    \tdata: {\n    \t id: id,\n    \t success: success,\n    \t detail: fileInfo.clientDetail\n    \t}\n    }\n    * and it's waiting from client data formatted like this:\n    *\n    {\n    \tactionType: '...',\n    \tmessage: {...}\n    }\n    * /!\\ If wrapData is wrong configured is interpreted as false /!\\\n    */\n\n    self.wrapData = _getOption(\"wrapData\", false);\n\n    var _isWrapDataWellConfigured = function _isWrapDataWellConfigured() {\n      if (typeof self.wrapData === \"boolean\") {\n        return true;\n      }\n\n      if (typeof self.wrapData !== \"object\" || Array.isArray(self.wrapData)) {\n        return false;\n      }\n\n      if (!self.wrapData.wrapKey || typeof self.wrapData.wrapKey.action !== \"string\" || typeof self.wrapData.wrapKey.message !== \"string\" || !self.wrapData.unwrapKey || typeof self.wrapData.unwrapKey.action !== \"string\" || typeof self.wrapData.unwrapKey.message !== \"string\") {\n        return false;\n      }\n\n      return true;\n    };\n    /**\n     * Allow user to access to some private function to customize message reception.\n     * This is used if you specified wrapOptions on the client side and have to manually bind message to callback.\n     */\n\n\n    self.exposePrivateFunction = _getOption(\"exposePrivateFunction\", false);\n\n    var _getTopicName = function _getTopicName(topicExtension) {\n      if (self.wrapData) {\n        return self.topicName;\n      }\n\n      return self.topicName + topicExtension;\n    };\n\n    var _wrapData = function _wrapData(data, action) {\n      if (!_isWrapDataWellConfigured() || !self.wrapData) {\n        return data;\n      }\n\n      var dataWrapped = {};\n\n      if (self.wrapData.additionalData) {\n        Object.assign(dataWrapped, self.wrapData.additionalData);\n      }\n\n      var actionKey = self.wrapData.wrapKey && typeof self.wrapData.wrapKey.action === \"string\" ? self.wrapData.wrapKey.action : \"action\";\n      var messageKey = self.wrapData.wrapKey && typeof self.wrapData.wrapKey.message === \"string\" ? self.wrapData.wrapKey.message : \"message\";\n      dataWrapped[actionKey] = action;\n      dataWrapped[messageKey] = data;\n      return dataWrapped;\n    };\n    /**\n     * Private method to dispatch a custom event on the instance.\n     * @param  {string} eventName  Name for which listeners can listen.\n     * @param  {object} properties An object literal with additional properties\n     *                             to be attached to the event object.\n     * @return {boolean} false if any callback returned false; true otherwise\n     */\n\n\n    var _dispatch = function _dispatch(eventName, properties) {\n      var evnt = document.createEvent(\"Event\");\n      evnt.initEvent(eventName, false, false);\n\n      for (var prop in properties) {\n        if (properties.hasOwnProperty(prop)) {\n          evnt[prop] = properties[prop];\n        }\n      }\n\n      return self.dispatchEvent(evnt);\n    };\n    /**\n     * Private method to bind an event listener.  Useful to ensure that all\n     * events have been unbound.  Inspired by Backbone.js.\n     */\n\n\n    var _listenedReferences = [];\n\n    var _listenTo = function _listenTo(object, eventName, callback, bubble) {\n      object.addEventListener(eventName, callback, bubble);\n\n      _listenedReferences.push(arguments);\n    };\n\n    var _stopListeningTo = function _stopListeningTo(object, eventName, callback, bubble) {\n      if (object.removeEventListener) {\n        object.removeEventListener(eventName, callback, bubble);\n      }\n    };\n\n    var _stopListening = function _stopListening() {\n      for (var i = _listenedReferences.length - 1; i >= 0; i--) {\n        _stopListeningTo.apply(this, _listenedReferences[i]);\n      }\n\n      _listenedReferences = [];\n    };\n    /**\n     * Private closure for the _load function.\n     * @param  {File} file A W3C File object\n     * @return {void}\n     */\n\n\n    var _loadOne = function _loadOne(file) {\n      // First check for file size\n      if (self.maxFileSize !== null && file.size > self.maxFileSize) {\n        _dispatch(\"error\", {\n          file: file,\n          message: \"Attempt by client to upload file exceeding the maximum file size\",\n          code: 1\n        });\n\n        return;\n      } // Dispatch an event to listeners and stop now if they don't want\n      // this file to be uploaded.\n\n\n      var evntResult = _dispatch(\"start\", {\n        file: file\n      });\n\n      if (!evntResult) return; // Scope variables\n\n      var reader = new FileReader(),\n          id = window.siofu_global.downloads++,\n          uploadComplete = false,\n          useText = self.useText,\n          offset = 0,\n          newName;\n      if (reader._realReader) reader = reader._realReader; // Support Android Crosswalk\n\n      uploadedFiles[id] = file; // An object for the outside to use to communicate with us\n\n      var communicator = {\n        id: id\n      }; // Calculate chunk size\n\n      var chunkSize = self.chunkSize;\n      if (chunkSize >= file.size || chunkSize <= 0) chunkSize = file.size; // Private function to handle transmission of file data\n\n      var transmitPart = function transmitPart(start, end, content) {\n        var isBase64 = false;\n\n        if (!useText) {\n          try {\n            var uintArr = new Uint8Array(content); // Support the transmission of serialized ArrayBuffers\n            // for experimental purposes, but default to encoding the\n            // transmission in Base 64.\n\n            if (self.serializedOctets) {\n              content = uintArr;\n            } else if (self.useBuffer) {\n              content = uintArr.buffer;\n            } else {\n              isBase64 = true;\n              content = _uint8ArrayToBase64(uintArr);\n            }\n          } catch (error) {\n            socket.emit(_getTopicName(\"_done\"), _wrapData({\n              id: id,\n              interrupt: true\n            }, \"done\"));\n            return;\n          }\n        } // TODO override the send data\n\n\n        socket.emit(_getTopicName(\"_progress\"), _wrapData({\n          id: id,\n          size: file.size,\n          start: start,\n          end: end,\n          content: content,\n          base64: isBase64\n        }, \"progress\"));\n      }; // Callback when tranmission is complete.\n\n\n      var transmitDone = function transmitDone() {\n        socket.emit(_getTopicName(\"_done\"), _wrapData({\n          id: id\n        }, \"done\"));\n      }; // Load a \"chunk\" of the file from offset to offset+chunkSize.\n      //\n      // Note that FileReader has its own \"progress\" event.  However,\n      // it has not proven to be reliable enough for production. See\n      // Stack Overflow question #16713386.\n      //\n      // To compensate, we will manually load the file in chunks of a\n      // size specified by the user in the uploader.chunkSize property.\n\n\n      var processChunk = function processChunk() {\n        // Abort if we are told to do so.\n        if (communicator.abort) return;\n        var chunk = file.slice(offset, Math.min(offset + chunkSize, file.size));\n\n        if (useText) {\n          reader.readAsText(chunk);\n        } else {\n          reader.readAsArrayBuffer(chunk);\n        }\n      }; // Callback for when the reader has completed a load event.\n\n\n      var loadCb = function loadCb(event) {\n        // Abort if we are told to do so.\n        if (communicator.abort) return; // Transmit the newly loaded data to the server and emit a client event\n\n        var bytesLoaded = Math.min(offset + chunkSize, file.size);\n        transmitPart(offset, bytesLoaded, event.target.result);\n\n        _dispatch(\"progress\", {\n          file: file,\n          bytesLoaded: bytesLoaded,\n          name: newName\n        }); // Get ready to send the next chunk\n\n\n        offset += chunkSize;\n\n        if (offset >= file.size) {\n          // All done!\n          transmitDone();\n\n          _dispatch(\"load\", {\n            file: file,\n            reader: reader,\n            name: newName\n          });\n\n          uploadComplete = true;\n        }\n      };\n\n      _listenTo(reader, \"load\", loadCb); // Listen for an \"error\" event.  Stop the transmission if one is received.\n\n\n      _listenTo(reader, \"error\", function () {\n        socket.emit(_getTopicName(\"_done\"), _wrapData({\n          id: id,\n          interrupt: true\n        }, \"done\"));\n\n        _stopListeningTo(reader, \"load\", loadCb);\n      }); // Do the same for the \"abort\" event.\n\n\n      _listenTo(reader, \"abort\", function () {\n        socket.emit(_getTopicName(\"_done\"), _wrapData({\n          id: id,\n          interrupt: true\n        }, \"done\"));\n\n        _stopListeningTo(reader, \"load\", loadCb);\n      }); // Transmit the \"start\" message to the server.\n\n\n      socket.emit(_getTopicName(\"_start\"), _wrapData({\n        name: file.name,\n        mtime: file.lastModified,\n        meta: file.meta,\n        size: file.size,\n        encoding: useText ? \"text\" : \"octet\",\n        id: id\n      }, \"start\")); // To avoid a race condition, we don't want to start transmitting to the\n      // server until the server says it is ready.\n\n      var readyCallback = function readyCallback(_newName) {\n        newName = _newName;\n        processChunk();\n      };\n\n      var chunkCallback = function chunkCallback() {\n        if (!uploadComplete) processChunk();\n      };\n\n      readyCallbacks[id] = readyCallback;\n      chunkCallbacks[id] = chunkCallback;\n      return communicator;\n    };\n    /**\n     * Private function to load the file into memory using the HTML5 FileReader object\n     * and then transmit that file through Socket.IO.\n     *\n     * @param  {FileList} files An array of files\n     * @return {void}\n     */\n\n\n    var _load = function _load(files) {\n      // Iterate through the array of files.\n      for (var i = 0; i < files.length; i++) {\n        // Evaluate each file in a closure, because we will need a new\n        // instance of FileReader for each file.\n        var communicator = _loadOne(files[i]);\n\n        communicators[communicator.id] = communicator;\n      }\n    };\n    /**\n     * Private function to fetch an HTMLInputElement instance that can be used\n     * during the file selection process.\n     * @return {void}\n     */\n\n\n    var _getInputElement = function _getInputElement() {\n      var inpt = document.getElementById(self.fileInputElementId);\n\n      if (!inpt) {\n        inpt = document.createElement(\"input\");\n        inpt.setAttribute(\"type\", \"file\");\n        inpt.setAttribute(\"id\", self.fileInputElementId);\n        inpt.style.display = \"none\";\n        document.body.appendChild(inpt);\n      }\n\n      return inpt;\n    };\n    /**\n     * Private function to remove an HTMLInputElement created by this instance\n     * of SIOFU.\n     *\n     * @return {void}\n     */\n\n\n    var _removeInputElement = function _removeInputElement() {\n      var inpt = document.getElementById(self.fileInputElementId);\n\n      if (inpt) {\n        inpt.parentNode.removeChild(inpt);\n      }\n    };\n\n    var _baseFileSelectCallback = function _baseFileSelectCallback(files) {\n      if (files.length === 0) return; // Ensure existence of meta property on each file\n\n      for (var i = 0; i < files.length; i++) {\n        if (!files[i].meta) files[i].meta = {};\n      } // Dispatch the \"choose\" event\n\n\n      var evntResult = _dispatch(\"choose\", {\n        files: files\n      }); // If the callback didn't return false, continue with the upload\n\n\n      if (evntResult) {\n        _load(files);\n      }\n    };\n    /**\n     * Private function that serves as a callback on file input.\n     * @param  {Event} event The file input change event\n     * @return {void}\n     */\n\n\n    var _fileSelectCallback = function _fileSelectCallback(event) {\n      var files = event.target.files || event.dataTransfer.files;\n      event.preventDefault();\n\n      _baseFileSelectCallback(files);\n\n      if (self.resetFileInputs) {\n        try {\n          event.target.value = \"\"; //for IE11, latest Chrome/Firefox/Opera...\n        } catch (err) {// ignore\n        }\n\n        if (event.target.value) {\n          //for IE5 ~ IE10\n          var form = document.createElement(\"form\"),\n              parentNode = event.target.parentNode,\n              ref = event.target.nextSibling;\n          form.appendChild(event.target);\n          form.reset();\n          parentNode.insertBefore(event.target, ref);\n        }\n      }\n    };\n    /**\n     * Submit files at arbitrary time\n     * @param {FileList} files Files received form the input element.\n     * @return {void}\n     */\n\n\n    this.submitFiles = function (files) {\n      if (files) {\n        _baseFileSelectCallback(files);\n      }\n    };\n    /**\n     * Use a submitButton to upload files from the field given\n     * @param {HTMLInputElement} submitButton the button that the user has to\n     *                           click to start the upload\n     * @param {HTMLInputElement} input the field with the data to upload\n     *\n     * @return {void}\n     */\n\n\n    this.listenOnSubmit = function (submitButton, input) {\n      if (!input.files) return;\n\n      _listenTo(submitButton, \"click\", function () {\n        _baseFileSelectCallback(input.files);\n      }, false);\n    };\n    /**\n     * Use a submitButton to upload files from the field given\n     * @param {HTMLInputElement} submitButton the button that the user has to\n     *                           click to start the upload\n     * @param {Array} array an array of fields with the files to upload\n     *\n     * @return {void}\n     */\n\n\n    this.listenOnArraySubmit = function (submitButton, array) {\n      for (var index in array) {\n        this.listenOnSubmit(submitButton, array[index]);\n      }\n    };\n    /**\n     * Use a file input to activate this instance of the file uploader.\n     * @param  {HTMLInputElement} inpt The input element (e.g., as returned by\n     *                                 document.getElementById(\"yourId\"))\n     * @return {void}\n     */\n\n\n    this.listenOnInput = function (inpt) {\n      if (!inpt.files) return;\n\n      _listenTo(inpt, \"change\", _fileSelectCallback, false);\n    };\n    /**\n     * Accept files dropped on an element and upload them using this instance\n     * of the file uploader.\n     * @param  {HTMLELement} div Any HTML element.  When the user drags a file\n     *                           or files onto this element, those files will\n     *                           be processed by the instance.\n     * @return {void}\n     */\n\n\n    this.listenOnDrop = function (div) {\n      // We need to preventDefault on the dragover event in order for the\n      // drag-and-drop operation to work.\n      _listenTo(div, \"dragover\", function (event) {\n        event.preventDefault();\n      }, false);\n\n      _listenTo(div, \"drop\", _fileSelectCallback);\n    };\n    /**\n     * Display a dialog box for the user to select a file.  The file will then\n     * be uploaded using this instance of SocketIOFileUpload.\n     *\n     * This method works in all current browsers except Firefox, though Opera\n     * requires that the input element be visible.\n     *\n     * @return {void}\n     */\n\n\n    this.prompt = function () {\n      var inpt = _getInputElement(); // Listen for the \"change\" event on the file input element.\n\n\n      _listenTo(inpt, \"change\", _fileSelectCallback, false); // Fire a click event on the input element.  Firefox does not allow\n      // programatic clicks on input elements, but the other browsers do.\n      // Note that Opera requires that the element be visible when \"clicked\".\n\n\n      var evnt = document.createEvent(\"MouseEvents\");\n      evnt.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n      inpt.dispatchEvent(evnt);\n    };\n    /**\n     * Destroy an instance of Socket.IO file upload (i.e., unbind events and\n     * relieve memory).\n     *\n     * IMPORTANT: To finish the memory relief process, set all external\n     * references to this instance of SIOFU (including the reference used to\n     * call this destroy function) to null.\n     *\n     * @return {void}\n     */\n\n\n    this.destroy = function () {\n      _stopListening();\n\n      _removeInputElement();\n\n      for (var id in communicators) {\n        if (communicators.hasOwnProperty(id)) {\n          communicators[id].abort = true;\n        }\n      }\n\n      callbacks = null, uploadedFiles = null, readyCallbacks = null, communicators = null;\n    };\n    /**\n     * Registers an event listener.  If the callback function returns false,\n     * the file uploader will stop uploading the current file.\n     * @param  {string}   eventName Type of event for which to listen.\n     * @param  {Function} callback  Listener function.  Will be passed the\n     *                              event as an argument when the event occurs.\n     * @return {void}\n     */\n\n\n    this.addEventListener = function (eventName, callback) {\n      if (!callbacks[eventName]) callbacks[eventName] = [];\n      callbacks[eventName].push(callback);\n    };\n    /**\n     * Removes an event listener.\n     * @param  {string}   eventName Type of event.\n     * @param  {Function} callback  Listener function to remove.\n     * @return {boolean}            true if callback removed; false otherwise\n     */\n\n\n    this.removeEventListener = function (eventName, callback) {\n      if (!callbacks[eventName]) return false;\n\n      for (var i = 0; i < callbacks[eventName].length; i++) {\n        if (callbacks[eventName][i] === callback) {\n          callbacks[eventName].splice(i, 1);\n          return true;\n        }\n      }\n\n      return false;\n    };\n    /**\n     * Dispatches an event into this instance's event model.\n     * @param  {Event} evnt The event to dispatch.\n     * @return {boolean} false if any callback returned false; true otherwise\n     */\n\n\n    this.dispatchEvent = function (evnt) {\n      var eventCallbacks = callbacks[evnt.type];\n      if (!eventCallbacks) return true;\n      var retVal = true;\n\n      for (var i = 0; i < eventCallbacks.length; i++) {\n        var callbackResult = eventCallbacks[i](evnt);\n\n        if (callbackResult === false) {\n          retVal = false;\n        }\n      }\n\n      return retVal;\n    }; // OTHER LIBRARIES\n\n    /*\n     * base64-arraybuffer\n     * https://github.com/niklasvh/base64-arraybuffer\n     *\n     * Copyright (c) 2012 Niklas von Hertzen\n     * Licensed under the MIT license.\n     *\n     * Adapted for SocketIOFileUpload.\n     */\n\n\n    var _uint8ArrayToBase64 = function _uint8ArrayToBase64(bytes) {\n      var i,\n          len = bytes.buffer.byteLength,\n          base64 = \"\",\n          chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n      for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64 += chars[bytes[i + 2] & 63];\n      }\n\n      if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + \"=\";\n      } else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + \"==\";\n      }\n\n      return base64;\n    }; // END OTHER LIBRARIES\n\n\n    var _chunckCallback = function _chunckCallback(data) {\n      if (chunkCallbacks[data.id]) chunkCallbacks[data.id]();\n    };\n\n    var _readyCallback = function _readyCallback(data) {\n      if (readyCallbacks[data.id]) readyCallbacks[data.id](data.name);\n    };\n\n    var _completCallback = function _completCallback(data) {\n      if (uploadedFiles[data.id]) {\n        _dispatch(\"complete\", {\n          file: uploadedFiles[data.id],\n          detail: data.detail,\n          success: data.success\n        });\n      }\n    };\n\n    var _errorCallback = function _errorCallback(data) {\n      if (uploadedFiles[data.id]) {\n        _dispatch(\"error\", {\n          file: uploadedFiles[data.id],\n          message: data.message,\n          code: 0\n        });\n\n        if (communicators) communicators[data.id].abort = true;\n      }\n    }; // CONSTRUCTOR: Listen to the \"complete\", \"ready\", and \"error\" messages\n    // on the socket.\n\n\n    if (_isWrapDataWellConfigured() && self.wrapData) {\n      var mapActionToCallback = {\n        chunk: _chunckCallback,\n        ready: _readyCallback,\n        complete: _completCallback,\n        error: _errorCallback\n      };\n\n      _listenTo(socket, _getTopicName(), function (message) {\n        if (typeof message !== \"object\") {\n          console.log(\"SocketIOFileUploadClient Error: You choose to wrap your data so the message from the server need to be an object\"); // eslint-disable-line no-console\n\n          return;\n        }\n\n        var actionKey = self.wrapData.unwrapKey && typeof self.wrapData.unwrapKey.action === \"string\" ? self.wrapData.unwrapKey.action : \"action\";\n        var messageKey = self.wrapData.unwrapKey && typeof self.wrapData.unwrapKey.message === \"string\" ? self.wrapData.unwrapKey.message : \"message\";\n        var action = message[actionKey];\n        var data = message[messageKey];\n\n        if (!action || !data || !mapActionToCallback[action]) {\n          console.log(\"SocketIOFileUploadClient Error: You choose to wrap your data but the message from the server is wrong configured. Check the message and your wrapData option\"); // eslint-disable-line no-console\n\n          return;\n        }\n\n        mapActionToCallback[action](data);\n      });\n    } else {\n      _listenTo(socket, _getTopicName(\"_chunk\"), _chunckCallback);\n\n      _listenTo(socket, _getTopicName(\"_ready\"), _readyCallback);\n\n      _listenTo(socket, _getTopicName(\"_complete\"), _completCallback);\n\n      _listenTo(socket, _getTopicName(\"_error\"), _errorCallback);\n    }\n\n    if (this.exposePrivateFunction) {\n      this.chunckCallback = _chunckCallback;\n      this.readyCallback = _readyCallback;\n      this.completCallback = _completCallback;\n      this.errorCallback = _errorCallback;\n    }\n  };\n});","map":{"version":3,"names":["scope","name","factory","define","amd","module","exports","socket","options","self","window","File","FileReader","Error","siofu_global","instances","downloads","callbacks","uploadedFiles","chunkCallbacks","readyCallbacks","communicators","_getOption","key","defaultValue","fileInputElementId","resetFileInputs","useText","serializedOctets","useBuffer","chunkSize","topicName","wrapData","_isWrapDataWellConfigured","Array","isArray","wrapKey","action","message","unwrapKey","exposePrivateFunction","_getTopicName","topicExtension","_wrapData","data","dataWrapped","additionalData","Object","assign","actionKey","messageKey","_dispatch","eventName","properties","evnt","document","createEvent","initEvent","prop","hasOwnProperty","dispatchEvent","_listenedReferences","_listenTo","object","callback","bubble","addEventListener","push","arguments","_stopListeningTo","removeEventListener","_stopListening","i","length","apply","_loadOne","file","maxFileSize","size","code","evntResult","reader","id","uploadComplete","offset","newName","_realReader","communicator","transmitPart","start","end","content","isBase64","uintArr","Uint8Array","buffer","_uint8ArrayToBase64","error","emit","interrupt","base64","transmitDone","processChunk","abort","chunk","slice","Math","min","readAsText","readAsArrayBuffer","loadCb","event","bytesLoaded","target","result","mtime","lastModified","meta","encoding","readyCallback","_newName","chunkCallback","_load","files","_getInputElement","inpt","getElementById","createElement","setAttribute","style","display","body","appendChild","_removeInputElement","parentNode","removeChild","_baseFileSelectCallback","_fileSelectCallback","dataTransfer","preventDefault","value","err","form","ref","nextSibling","reset","insertBefore","submitFiles","listenOnSubmit","submitButton","input","listenOnArraySubmit","array","index","listenOnInput","listenOnDrop","div","prompt","initMouseEvent","destroy","splice","eventCallbacks","type","retVal","callbackResult","bytes","len","byteLength","chars","substring","_chunckCallback","_readyCallback","_completCallback","detail","success","_errorCallback","mapActionToCallback","ready","complete","console","log","chunckCallback","completCallback","errorCallback"],"sources":["/Users/imac/Downloads/Crash.BTC.Updated.V2.DEV/Frontend/node_modules/socketio-file-upload/client.js"],"sourcesContent":["/*\n *                 Copyright (C) 2015 Shane Carr and others\n *                               X11 License\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n *\n * Except as contained in this notice, the names of the authors or copyright\n * holders shall not be used in advertising or otherwise to promote the sale,\n * use or other dealings in this Software without prior written authorization\n * from the authors or copyright holders.\n */\n\n// Do not check function indentation because this is intentionally ignored in order to preserve history in git.\n/* eslint-disable indent */\n\n/*\n * A client-side JavaScript object to handle file uploads to a Node.JS server\n * via Socket.IO.\n * @implements EventTarget\n * @param {SocketIO} socket The current Socket.IO connection.\n */\n(function (scope, name, factory) {\n\t/* eslint-disable no-undef */\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine([], factory);\n\t}\n\telse if (typeof module === \"object\" && module.exports) {\n\t\tmodule.exports = factory();\n\t}\n\telse {\n\t\tscope[name] = factory();\n\t}\n\t/* eslint-enable no-undef */\n}(this, \"SocketIOFileUpload\", function () {\n return function (socket, options) {\n\t\"use strict\";\n\n\tvar self = this; // avoids context issues\n\n\t// Check for compatibility\n\tif (!window.File || !window.FileReader) {\n\t\tthrow new Error(\"Socket.IO File Upload: Browser Not Supported\");\n\t}\n\n\tif ( !window.siofu_global ) {\n\t\twindow.siofu_global = {\n\t\t\tinstances: 0,\n\t\t\tdownloads: 0\n\t\t};\n\t}\n\n\t// Private and Public Variables\n\tvar callbacks = {},\n\t\tuploadedFiles = {},\n\t\tchunkCallbacks = {},\n\t\treadyCallbacks = {},\n\t\tcommunicators = {};\n\n\tvar _getOption = function (key, defaultValue) {\n\t\tif(!options) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn options[key] || defaultValue;\n\t};\n\n\tself.fileInputElementId = \"siofu_input_\"+window.siofu_global.instances++;\n\tself.resetFileInputs = true;\n\tself.useText = _getOption(\"useText\", false);\n\tself.serializedOctets = _getOption(\"serializedOctets\", false);\n\tself.useBuffer = _getOption(\"useBuffer\", true);\n\tself.chunkSize = _getOption(\"chunkSize\", 1024 * 100); // 100kb default chunk size\n\tself.topicName = _getOption(\"topicName\", \"siofu\");\n\n\t/**\n\t* WrapData allow you to wrap the Siofu messages into a predefined format.\n\t* You can then easily use Siofu packages even in strongly typed topic.\n\t* wrapData can be a boolean or an object. It is false by default.\n\t* If wrapData is true it will allow you to send all the messages to only one topic by wrapping the siofu actions and messages.\n\t*\n\t* ex:\n\t{\n\t\taction: 'complete',\n\t\tmessage: {\n\t\t id: id,\n\t\t success: success,\n\t\t detail: fileInfo.clientDetail\n\t\t}\n\t}\n\t*\n\t* If wrapData is an object constituted of two mandatory key and one optional:\n\t* wrapKey and unwrapKey (mandatory): Corresponding to the key used to wrap the siofu data and message\n\t* additionalData (optional): Corresponding to the data to send along with file data\n\t*\n\t* ex:\n\t* if wrapData = {\n\t\twrapKey: {\n\t\t\taction: 'actionType',\n\t\t\tmessage: 'data'\n\t\t},\n\t\tunwrapKey: {\n\t\t\taction: 'actionType',\n\t\t\tmessage: 'message'\n\t\t},\n\t\tadditionalData: {\n\t\t\tacknowledgement: true\n\t\t}\n\t}\n\t* When Siofu will send for example a complete message this will send:\n\t*\n\t{\n\t\tacknowledgement: true,\n\t\tactionType: 'complete',\n\t\tdata: {\n\t\t id: id,\n\t\t success: success,\n\t\t detail: fileInfo.clientDetail\n\t\t}\n\t}\n\t* and it's waiting from client data formatted like this:\n\t*\n\t{\n\t\tactionType: '...',\n\t\tmessage: {...}\n\t}\n\t* /!\\ If wrapData is wrong configured is interpreted as false /!\\\n\t*/\n\tself.wrapData = _getOption(\"wrapData\", false);\n\n\tvar _isWrapDataWellConfigured = function () {\n\t\tif (typeof self.wrapData === \"boolean\") {\n\t\t\treturn true;\n\t\t}\n\t\tif (typeof self.wrapData !== \"object\" || Array.isArray(self.wrapData)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif(!self.wrapData.wrapKey || typeof self.wrapData.wrapKey.action !== \"string\" || typeof self.wrapData.wrapKey.message !== \"string\" ||\n\t\t\t!self.wrapData.unwrapKey || typeof self.wrapData.unwrapKey.action !== \"string\" || typeof self.wrapData.unwrapKey.message !== \"string\") {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\n\t/**\n\t * Allow user to access to some private function to customize message reception.\n\t * This is used if you specified wrapOptions on the client side and have to manually bind message to callback.\n\t */\n\tself.exposePrivateFunction = _getOption(\"exposePrivateFunction\", false);\n\n\tvar _getTopicName = function (topicExtension) {\n\t\tif (self.wrapData) {\n\t\t\treturn self.topicName;\n\t\t}\n\n\t\treturn self.topicName + topicExtension;\n\t};\n\n\tvar _wrapData = function (data, action) {\n\t\tif(!_isWrapDataWellConfigured() || !self.wrapData) {\n\t\t\treturn data;\n\t\t}\n\t\tvar dataWrapped = {};\n\t\tif(self.wrapData.additionalData) {\n\t\t\tObject.assign(dataWrapped, self.wrapData.additionalData);\n\t\t}\n\n\t\tvar actionKey = self.wrapData.wrapKey && typeof self.wrapData.wrapKey.action === \"string\" ? self.wrapData.wrapKey.action : \"action\";\n\t\tvar messageKey = self.wrapData.wrapKey && typeof self.wrapData.wrapKey.message === \"string\" ? self.wrapData.wrapKey.message : \"message\";\n\n\t\tdataWrapped[actionKey] = action;\n\t\tdataWrapped[messageKey] = data;\n\t\treturn dataWrapped;\n\t};\n\n\t/**\n\t * Private method to dispatch a custom event on the instance.\n\t * @param  {string} eventName  Name for which listeners can listen.\n\t * @param  {object} properties An object literal with additional properties\n\t *                             to be attached to the event object.\n\t * @return {boolean} false if any callback returned false; true otherwise\n\t */\n\tvar _dispatch = function (eventName, properties) {\n\t\tvar evnt = document.createEvent(\"Event\");\n\t\tevnt.initEvent(eventName, false, false);\n\t\tfor (var prop in properties) {\n\t\t\tif (properties.hasOwnProperty(prop)) {\n\t\t\t\tevnt[prop] = properties[prop];\n\t\t\t}\n\t\t}\n\t\treturn self.dispatchEvent(evnt);\n\t};\n\n\t/**\n\t * Private method to bind an event listener.  Useful to ensure that all\n\t * events have been unbound.  Inspired by Backbone.js.\n\t */\n\tvar _listenedReferences = [];\n\tvar _listenTo = function (object, eventName, callback, bubble) {\n\t\tobject.addEventListener(eventName, callback, bubble);\n\t\t_listenedReferences.push(arguments);\n\t};\n\tvar _stopListeningTo = function (object, eventName, callback, bubble) {\n\t\tif (object.removeEventListener) {\n\t\t\tobject.removeEventListener(eventName, callback, bubble);\n\t\t}\n\t};\n\tvar _stopListening = function () {\n\t\tfor (var i = _listenedReferences.length - 1; i >= 0; i--) {\n\t\t\t_stopListeningTo.apply(this, _listenedReferences[i]);\n\t\t}\n\t\t_listenedReferences = [];\n\t};\n\n\t/**\n\t * Private closure for the _load function.\n\t * @param  {File} file A W3C File object\n\t * @return {void}\n\t */\n\tvar _loadOne = function (file) {\n\t\t// First check for file size\n\t\tif (self.maxFileSize !== null && file.size > self.maxFileSize) {\n\t\t\t_dispatch(\"error\", {\n\t\t\t\tfile: file,\n\t\t\t\tmessage: \"Attempt by client to upload file exceeding the maximum file size\",\n\t\t\t\tcode: 1\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Dispatch an event to listeners and stop now if they don't want\n\t\t// this file to be uploaded.\n\t\tvar evntResult = _dispatch(\"start\", {\n\t\t\tfile: file\n\t\t});\n\t\tif (!evntResult) return;\n\n\t\t// Scope variables\n\t\tvar reader = new FileReader(),\n\t\t\tid = window.siofu_global.downloads++,\n\t\t\tuploadComplete = false,\n\t\t\tuseText = self.useText,\n\t\t\toffset = 0,\n\t\t\tnewName;\n\t\tif (reader._realReader) reader = reader._realReader; // Support Android Crosswalk\n\t\tuploadedFiles[id] = file;\n\n\t\t// An object for the outside to use to communicate with us\n\t\tvar communicator = { id: id };\n\n\t\t// Calculate chunk size\n\t\tvar chunkSize = self.chunkSize;\n\t\tif (chunkSize >= file.size || chunkSize <= 0) chunkSize = file.size;\n\n\t\t// Private function to handle transmission of file data\n\t\tvar transmitPart = function (start, end, content) {\n\t\t\tvar isBase64 = false;\n\t\t\tif (!useText) {\n\t\t\t\ttry {\n\t\t\t\t\tvar uintArr = new Uint8Array(content);\n\n\t\t\t\t\t// Support the transmission of serialized ArrayBuffers\n\t\t\t\t\t// for experimental purposes, but default to encoding the\n\t\t\t\t\t// transmission in Base 64.\n\t\t\t\t\tif (self.serializedOctets) {\n\t\t\t\t\t\tcontent = uintArr;\n\t\t\t\t\t}\n\t\t\t\t\telse if (self.useBuffer) {\n\t\t\t\t\t\tcontent = uintArr.buffer;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisBase64 = true;\n\t\t\t\t\t\tcontent = _uint8ArrayToBase64(uintArr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (error) {\n\t\t\t\t\tsocket.emit(_getTopicName(\"_done\"), _wrapData({\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\tinterrupt: true\n\t\t\t\t\t}, \"done\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO override the send data\n\t\t\tsocket.emit(_getTopicName(\"_progress\"), _wrapData({\n\t\t\t\tid: id,\n\t\t\t\tsize: file.size,\n\t\t\t\tstart: start,\n\t\t\t\tend: end,\n\t\t\t\tcontent: content,\n\t\t\t\tbase64: isBase64\n\t\t\t}, \"progress\"));\n\t\t};\n\n\t\t// Callback when tranmission is complete.\n\t\tvar transmitDone = function () {\n\t\t\tsocket.emit(_getTopicName(\"_done\"), _wrapData({\n\t\t\t\tid: id\n\t\t\t}, \"done\"));\n\t\t};\n\n\t\t// Load a \"chunk\" of the file from offset to offset+chunkSize.\n\t\t//\n\t\t// Note that FileReader has its own \"progress\" event.  However,\n\t\t// it has not proven to be reliable enough for production. See\n\t\t// Stack Overflow question #16713386.\n\t\t//\n\t\t// To compensate, we will manually load the file in chunks of a\n\t\t// size specified by the user in the uploader.chunkSize property.\n\t\tvar processChunk = function () {\n\t\t\t// Abort if we are told to do so.\n\t\t\tif (communicator.abort) return;\n\n\t\t\tvar chunk = file.slice(offset, Math.min(offset+chunkSize, file.size));\n\t\t\tif (useText) {\n\t\t\t\treader.readAsText(chunk);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treader.readAsArrayBuffer(chunk);\n\t\t\t}\n\t\t};\n\n\t\t// Callback for when the reader has completed a load event.\n\t\tvar loadCb = function (event) {\n\t\t\t// Abort if we are told to do so.\n\t\t\tif (communicator.abort) return;\n\n\t\t\t// Transmit the newly loaded data to the server and emit a client event\n\t\t\tvar bytesLoaded = Math.min(offset+chunkSize, file.size);\n\t\t\ttransmitPart(offset, bytesLoaded, event.target.result);\n\t\t\t_dispatch(\"progress\", {\n\t\t\t\tfile: file,\n\t\t\t\tbytesLoaded: bytesLoaded,\n\t\t\t\tname: newName\n\t\t\t});\n\n\t\t\t// Get ready to send the next chunk\n\t\t\toffset += chunkSize;\n\t\t\tif (offset >= file.size) {\n\t\t\t\t// All done!\n\t\t\t\ttransmitDone();\n\t\t\t\t_dispatch(\"load\", {\n\t\t\t\t\tfile: file,\n\t\t\t\t\treader: reader,\n\t\t\t\t\tname: newName\n\t\t\t\t});\n\t\t\t\tuploadComplete = true;\n\t\t\t}\n\t\t};\n\t\t_listenTo(reader, \"load\", loadCb);\n\n\t\t// Listen for an \"error\" event.  Stop the transmission if one is received.\n\t\t_listenTo(reader, \"error\", function () {\n\t\t\tsocket.emit(_getTopicName(\"_done\"), _wrapData({\n\t\t\t\tid: id,\n\t\t\t\tinterrupt: true\n\t\t\t}, \"done\"));\n\t\t\t_stopListeningTo(reader, \"load\", loadCb);\n\t\t});\n\n\t\t// Do the same for the \"abort\" event.\n\t\t_listenTo(reader, \"abort\", function () {\n\t\t\tsocket.emit(_getTopicName(\"_done\"), _wrapData({\n\t\t\t\tid: id,\n\t\t\t\tinterrupt: true\n\t\t\t}, \"done\"));\n\t\t\t_stopListeningTo(reader, \"load\", loadCb);\n\t\t});\n\n\t\t// Transmit the \"start\" message to the server.\n\t\tsocket.emit(_getTopicName(\"_start\"), _wrapData({\n\t\t\tname: file.name,\n\t\t\tmtime: file.lastModified,\n\t\t\tmeta: file.meta,\n\t\t\tsize: file.size,\n\t\t\tencoding: useText ? \"text\" : \"octet\",\n\t\t\tid: id\n\t\t}, \"start\"));\n\n\t\t// To avoid a race condition, we don't want to start transmitting to the\n\t\t// server until the server says it is ready.\n\t\tvar readyCallback = function (_newName) {\n\t\t\tnewName = _newName;\n\t\t\tprocessChunk();\n\t\t};\n\t\tvar chunkCallback = function(){\n\t\t\tif ( !uploadComplete )\n\t\t\t\tprocessChunk();\n\t\t};\n\t\treadyCallbacks[id] = readyCallback;\n\t\tchunkCallbacks[id] = chunkCallback;\n\n\t\treturn communicator;\n\t};\n\n\t/**\n\t * Private function to load the file into memory using the HTML5 FileReader object\n\t * and then transmit that file through Socket.IO.\n\t *\n\t * @param  {FileList} files An array of files\n\t * @return {void}\n\t */\n\tvar _load = function (files) {\n\t\t// Iterate through the array of files.\n\t\tfor (var i = 0; i < files.length; i++) {\n\t\t\t// Evaluate each file in a closure, because we will need a new\n\t\t\t// instance of FileReader for each file.\n\t\t\tvar communicator = _loadOne(files[i]);\n\t\t\tcommunicators[communicator.id] = communicator;\n\t\t}\n\t};\n\n\t/**\n\t * Private function to fetch an HTMLInputElement instance that can be used\n\t * during the file selection process.\n\t * @return {void}\n\t */\n\tvar _getInputElement = function () {\n\t\tvar inpt = document.getElementById(self.fileInputElementId);\n\t\tif (!inpt) {\n\t\t\tinpt = document.createElement(\"input\");\n\t\t\tinpt.setAttribute(\"type\", \"file\");\n\t\t\tinpt.setAttribute(\"id\", self.fileInputElementId);\n\t\t\tinpt.style.display = \"none\";\n\t\t\tdocument.body.appendChild(inpt);\n\t\t}\n\t\treturn inpt;\n\t};\n\n\t/**\n\t * Private function to remove an HTMLInputElement created by this instance\n\t * of SIOFU.\n\t *\n\t * @return {void}\n\t */\n\tvar _removeInputElement = function () {\n\t\tvar inpt = document.getElementById(self.fileInputElementId);\n\t\tif (inpt) {\n\t\t\tinpt.parentNode.removeChild(inpt);\n\t\t}\n\t};\n\n\tvar _baseFileSelectCallback = function (files) {\n\t\tif (files.length === 0) return;\n\n\t\t// Ensure existence of meta property on each file\n\t\tfor (var i = 0; i < files.length; i++) {\n\t\t\tif(!files[i].meta) files[i].meta = {};\n\t\t}\n\n\t\t// Dispatch the \"choose\" event\n\t\tvar evntResult = _dispatch(\"choose\", {\n\t\t\tfiles: files\n\t\t});\n\n\t\t// If the callback didn't return false, continue with the upload\n\t\tif (evntResult) {\n\t\t\t_load(files);\n\t\t}\n\t};\n\n\t/**\n\t * Private function that serves as a callback on file input.\n\t * @param  {Event} event The file input change event\n\t * @return {void}\n\t */\n\tvar _fileSelectCallback = function (event) {\n\t\tvar files = event.target.files || event.dataTransfer.files;\n\t\tevent.preventDefault();\n\t\t_baseFileSelectCallback(files);\n\n\t\tif (self.resetFileInputs) {\n\t\t\ttry {\n\t\t\t\tevent.target.value = \"\"; //for IE11, latest Chrome/Firefox/Opera...\n\t\t\t} catch(err) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t\tif (event.target.value) { //for IE5 ~ IE10\n\t\t\t\tvar form = document.createElement(\"form\"),\n\t\t\t\tparentNode = event.target.parentNode, ref = event.target.nextSibling;\n\t\t\t\tform.appendChild(event.target);\n\t\t\t\tform.reset();\n\t\t\t\tparentNode.insertBefore(event.target, ref);\n\t\t\t}\n\t\t}\n\t};\n\n\n\t/**\n\t * Submit files at arbitrary time\n\t * @param {FileList} files Files received form the input element.\n\t * @return {void}\n\t */\n\tthis.submitFiles = function (files) {\n\t\tif (files) {\n\t\t\t_baseFileSelectCallback(files);\n\t\t}\n\t};\n\n\t/**\n\t * Use a submitButton to upload files from the field given\n\t * @param {HTMLInputElement} submitButton the button that the user has to\n\t *                           click to start the upload\n\t * @param {HTMLInputElement} input the field with the data to upload\n\t *\n\t * @return {void}\n\t */\n\tthis.listenOnSubmit = function (submitButton, input) {\n\t\tif (!input.files) return;\n\t\t_listenTo(submitButton, \"click\", function () {\n\t\t\t_baseFileSelectCallback(input.files);\n\t\t}, false);\n\t};\n\n\t/**\n\t * Use a submitButton to upload files from the field given\n\t * @param {HTMLInputElement} submitButton the button that the user has to\n\t *                           click to start the upload\n\t * @param {Array} array an array of fields with the files to upload\n\t *\n\t * @return {void}\n\t */\n\tthis.listenOnArraySubmit = function (submitButton, array) {\n\t\tfor (var index in array) {\n\t\t\tthis.listenOnSubmit(submitButton, array[index]);\n\t\t}\n\t};\n\n\t/**\n\t * Use a file input to activate this instance of the file uploader.\n\t * @param  {HTMLInputElement} inpt The input element (e.g., as returned by\n\t *                                 document.getElementById(\"yourId\"))\n\t * @return {void}\n\t */\n\tthis.listenOnInput = function (inpt) {\n\t\tif (!inpt.files) return;\n\t\t_listenTo(inpt, \"change\", _fileSelectCallback, false);\n\t};\n\n\t/**\n\t * Accept files dropped on an element and upload them using this instance\n\t * of the file uploader.\n\t * @param  {HTMLELement} div Any HTML element.  When the user drags a file\n\t *                           or files onto this element, those files will\n\t *                           be processed by the instance.\n\t * @return {void}\n\t */\n\tthis.listenOnDrop = function (div) {\n\t\t// We need to preventDefault on the dragover event in order for the\n\t\t// drag-and-drop operation to work.\n\t\t_listenTo(div, \"dragover\", function (event) {\n\t\t\tevent.preventDefault();\n\t\t}, false);\n\n\t\t_listenTo(div, \"drop\", _fileSelectCallback);\n\t};\n\n\t/**\n\t * Display a dialog box for the user to select a file.  The file will then\n\t * be uploaded using this instance of SocketIOFileUpload.\n\t *\n\t * This method works in all current browsers except Firefox, though Opera\n\t * requires that the input element be visible.\n\t *\n\t * @return {void}\n\t */\n\tthis.prompt = function () {\n\t\tvar inpt = _getInputElement();\n\n\t\t// Listen for the \"change\" event on the file input element.\n\t\t_listenTo(inpt, \"change\", _fileSelectCallback, false);\n\n\t\t// Fire a click event on the input element.  Firefox does not allow\n\t\t// programatic clicks on input elements, but the other browsers do.\n\t\t// Note that Opera requires that the element be visible when \"clicked\".\n\t\tvar evnt = document.createEvent(\"MouseEvents\");\n\t\tevnt.initMouseEvent(\"click\", true, true, window,\n\t\t\t0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\t\tinpt.dispatchEvent(evnt);\n\t};\n\n\t/**\n\t * Destroy an instance of Socket.IO file upload (i.e., unbind events and\n\t * relieve memory).\n\t *\n\t * IMPORTANT: To finish the memory relief process, set all external\n\t * references to this instance of SIOFU (including the reference used to\n\t * call this destroy function) to null.\n\t *\n\t * @return {void}\n\t */\n\tthis.destroy = function () {\n\t\t_stopListening();\n\t\t_removeInputElement();\n\t\tfor (var id in communicators) {\n\t\t\tif (communicators.hasOwnProperty(id)) {\n\t\t\t\tcommunicators[id].abort = true;\n\t\t\t}\n\t\t}\n\t\tcallbacks = null, uploadedFiles = null, readyCallbacks = null, communicators = null;\n\t};\n\n\t/**\n\t * Registers an event listener.  If the callback function returns false,\n\t * the file uploader will stop uploading the current file.\n\t * @param  {string}   eventName Type of event for which to listen.\n\t * @param  {Function} callback  Listener function.  Will be passed the\n\t *                              event as an argument when the event occurs.\n\t * @return {void}\n\t */\n\tthis.addEventListener = function (eventName, callback) {\n\t\tif (!callbacks[eventName]) callbacks[eventName] = [];\n\t\tcallbacks[eventName].push(callback);\n\t};\n\n\t/**\n\t * Removes an event listener.\n\t * @param  {string}   eventName Type of event.\n\t * @param  {Function} callback  Listener function to remove.\n\t * @return {boolean}            true if callback removed; false otherwise\n\t */\n\tthis.removeEventListener = function (eventName, callback) {\n\t\tif (!callbacks[eventName]) return false;\n\t\tfor (var i = 0; i < callbacks[eventName].length; i++) {\n\t\t\tif (callbacks[eventName][i] === callback) {\n\t\t\t\tcallbacks[eventName].splice(i, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Dispatches an event into this instance's event model.\n\t * @param  {Event} evnt The event to dispatch.\n\t * @return {boolean} false if any callback returned false; true otherwise\n\t */\n\tthis.dispatchEvent = function (evnt) {\n\t\tvar eventCallbacks = callbacks[evnt.type];\n\t\tif (!eventCallbacks) return true;\n\t\tvar retVal = true;\n\t\tfor (var i = 0; i < eventCallbacks.length; i++) {\n\t\t\tvar callbackResult = eventCallbacks[i](evnt);\n\t\t\tif (callbackResult === false) {\n\t\t\t\tretVal = false;\n\t\t\t}\n\t\t}\n\t\treturn retVal;\n\t};\n\n\t// OTHER LIBRARIES\n\t/*\n\t * base64-arraybuffer\n\t * https://github.com/niklasvh/base64-arraybuffer\n\t *\n\t * Copyright (c) 2012 Niklas von Hertzen\n\t * Licensed under the MIT license.\n\t *\n\t * Adapted for SocketIOFileUpload.\n\t */\n\tvar _uint8ArrayToBase64 = function (bytes) {\n\t\tvar i, len = bytes.buffer.byteLength, base64 = \"\",\n\t\t\tchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n\t\tfor (i = 0; i < len; i += 3) {\n\t\t\tbase64 += chars[bytes[i] >> 2];\n\t\t\tbase64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n\t\t\tbase64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n\t\t\tbase64 += chars[bytes[i + 2] & 63];\n\t\t}\n\n\t\tif ((len % 3) === 2) {\n\t\t\tbase64 = base64.substring(0, base64.length - 1) + \"=\";\n\t\t}\n\t\telse if (len % 3 === 1) {\n\t\t\tbase64 = base64.substring(0, base64.length - 2) + \"==\";\n\t\t}\n\n\t\treturn base64;\n\t};\n\t// END OTHER LIBRARIES\n\tvar _chunckCallback = function(data) {\n\t\tif ( chunkCallbacks[data.id] )\n\t\t\tchunkCallbacks[data.id]();\n\t};\n\n\tvar _readyCallback = function (data) {\n\t\tif (readyCallbacks[data.id])\n\t\t\treadyCallbacks[data.id](data.name);\n\t};\n\n\tvar _completCallback = function (data) {\n\t\tif (uploadedFiles[data.id]) {\n\t\t\t_dispatch(\"complete\", {\n\t\t\t\tfile: uploadedFiles[data.id],\n\t\t\t\tdetail: data.detail,\n\t\t\t\tsuccess: data.success\n\t\t\t});\n\t\t}\n\t};\n\n\tvar _errorCallback = function (data) {\n\t\tif ( uploadedFiles[data.id] ) {\n\t\t\t_dispatch(\"error\", {\n\t\t\t\tfile: uploadedFiles[data.id],\n\t\t\t\tmessage: data.message,\n\t\t\t\tcode: 0\n\t\t\t});\n\t\t\tif (communicators) communicators[data.id].abort = true;\n\t\t}\n\t};\n\n\t// CONSTRUCTOR: Listen to the \"complete\", \"ready\", and \"error\" messages\n\t// on the socket.\n\tif (_isWrapDataWellConfigured() && self.wrapData) {\n\t\tvar mapActionToCallback = {\n\t\t\tchunk: _chunckCallback,\n\t\t\tready: _readyCallback,\n\t\t\tcomplete: _completCallback,\n\t\t\terror: _errorCallback\n\t\t};\n\n\t\t_listenTo(socket, _getTopicName(), function (message) {\n\t\t\tif (typeof message !== \"object\") {\n\t\t\t\tconsole.log(\"SocketIOFileUploadClient Error: You choose to wrap your data so the message from the server need to be an object\"); // eslint-disable-line no-console\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar actionKey = self.wrapData.unwrapKey && typeof self.wrapData.unwrapKey.action === \"string\" ? self.wrapData.unwrapKey.action : \"action\";\n\t\t\tvar messageKey = self.wrapData.unwrapKey && typeof self.wrapData.unwrapKey.message === \"string\" ? self.wrapData.unwrapKey.message : \"message\";\n\n\t\t\tvar action = message[actionKey];\n\t\t\tvar data = message[messageKey];\n\t\t\tif (!action || !data || !mapActionToCallback[action]) {\n\t\t\t\tconsole.log(\"SocketIOFileUploadClient Error: You choose to wrap your data but the message from the server is wrong configured. Check the message and your wrapData option\"); // eslint-disable-line no-console\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmapActionToCallback[action](data);\n\t\t});\n\t} else {\n\t\t_listenTo(socket, _getTopicName(\"_chunk\"), _chunckCallback);\n\t\t_listenTo(socket, _getTopicName(\"_ready\"), _readyCallback);\n\t\t_listenTo(socket, _getTopicName(\"_complete\"), _completCallback);\n\t\t_listenTo(socket, _getTopicName(\"_error\"), _errorCallback);\n\t}\n\n\tif (this.exposePrivateFunction) {\n\t\tthis.chunckCallback = _chunckCallback;\n\t\tthis.readyCallback = _readyCallback;\n\t\tthis.completCallback = _completCallback;\n\t\tthis.errorCallback = _errorCallback;\n\t}\n };\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}